
import { Transaction, Account, Category } from '../types';
import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';
import * as XLSX from 'xlsx';
import { CATEGORY_COLORS } from '../constants';

export type ExportFormat = 'pdf' | 'csv' | 'json' | 'xlsx';
export type ExportPeriod = 'daily' | 'weekly' | 'monthly' | 'yearly' | 'all';

interface ExportOptions {
  format: ExportFormat;
  period: ExportPeriod;
  dateValue: string; 
}

const PDF_CURRENCY = 'INR '; 

export const exportData = async (
  transactions: Transaction[], 
  accounts: Account[], 
  categories: Category[],
  options: ExportOptions,
  customFiltered?: Transaction[]
) => {
  const { format, period, dateValue } = options;
  const sourceData = customFiltered || transactions;

  const filtered = sourceData.filter(t => {
    if (customFiltered) return true;
    if (period === 'all') return true;
    if (period === 'daily') return t.date === dateValue;
    if (period === 'monthly') return t.date.startsWith(dateValue);
    if (period === 'yearly') return t.date.startsWith(dateValue);
    if (period === 'weekly') {
      const start = new Date(dateValue);
      const end = new Date(start);
      end.setDate(start.getDate() + 7);
      const current = new Date(t.date);
      return current >= start && current < end;
    }
    return true;
  });

  const fileName = customFiltered ? `Filtered_Report_${Date.now()}` : `Zenith_Vault_${period}_${dateValue}`;

  try {
    if (format === 'csv') return generateCSV(filtered, accounts, categories, fileName);
    if (format === 'xlsx') return generateXLSX(filtered, accounts, categories, fileName);
    if (format === 'pdf') return generatePDF(filtered, accounts, categories, period, dateValue, fileName);
    if (format === 'json') return generateJSON(filtered, accounts, categories);
  } catch (err) {
    console.error("Export Engine Error:", err);
    throw err;
  }
};

const generateCSV = (transactions: Transaction[], accounts: Account[], categories: Category[], fileName: string) => {
  const headers = ['Date', 'Type', 'Description', 'Category', 'Amount', 'Account'];
  const rows = transactions.map(t => [
    t.date,
    t.type.toUpperCase(),
    `"${t.description.replace(/"/g, '""')}"`,
    `"${categories.find(c => c.id === t.categoryId)?.name || 'Unknown'}"`,
    t.amount,
    `"${accounts.find(a => a.id === t.fromAccountId)?.name || 'Unknown'}"`
  ].join(','));
  downloadFile([headers.join(','), ...rows].join('\n'), `${fileName}.csv`, 'text/csv');
};

const generateXLSX = (transactions: Transaction[], accounts: Account[], categories: Category[], fileName: string) => {
  const data = transactions.map(t => ({
    Date: t.date,
    Type: t.type.toUpperCase(),
    Description: t.description,
    Category: categories.find(c => c.id === t.categoryId)?.name || 'Unknown',
    Amount: t.amount,
    Account: accounts.find(a => a.id === t.fromAccountId)?.name || 'Unknown'
  }));
  const ws = XLSX.utils.json_to_sheet(data);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, "Audit");
  XLSX.writeFile(wb, `${fileName}.xlsx`);
};

const generatePDF = async (transactions: Transaction[], accounts: Account[], categories: Category[], period: string, date: string, fileName: string) => {
  const doc = new jsPDF('p', 'mm', 'a4');
  const margin = 20;
  const pageWidth = doc.internal.pageSize.getWidth();
  
  // 1. ZENITH EXECUTIVE HEADER
  doc.setFillColor(32, 33, 36); // Obsidian -> Dark Google Gray
  doc.rect(0, 0, pageWidth, 45, 'F');
  
  doc.setTextColor(66, 133, 244); // Gold -> Google Blue
  doc.setFontSize(22);
  doc.setFont('helvetica', 'bold');
  doc.text("ZENITH STATEMENT", margin, 25);
  
  doc.setFontSize(8);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(154, 160, 166); 
  doc.text(`CYCLE: ${period.toUpperCase()} • SCOPE: ${date} • GENERATED BY SOVEREIGN SYSTEM`, margin, 34);

  // 2. SUMMARY METRICS
  const income = transactions.filter(t => t.type === 'income').reduce((s, t) => s + t.amount, 0);
  const expense = transactions.filter(t => t.type === 'expense').reduce((s, t) => s + t.amount, 0);
  const net = income - expense;

  const cardY = 55;
  const cardW = (pageWidth - (margin * 2) - 10) / 3;

  const drawMetric = (x: number, label: string, val: number, color: [number, number, number]) => {
    doc.setDrawColor(60, 64, 67);
    doc.roundedRect(x, cardY, cardW, 22, 3, 3, 'D');
    doc.setFontSize(6);
    doc.setTextColor(154, 160, 166);
    doc.text(label, x + 4, cardY + 7);
    doc.setFontSize(11);
    doc.setTextColor(color[0], color[1], color[2]);
    doc.text(`${PDF_CURRENCY}${val.toLocaleString()}`, x + 4, cardY + 16);
  };

  drawMetric(margin, "TOTAL REVENUE", income, [15, 157, 88]); // Google Green
  drawMetric(margin + cardW + 5, "TOTAL EXPENDITURE", expense, [219, 68, 55]); // Google Red
  drawMetric(margin + (cardW * 2) + 10, "NET RETAINED", net, [66, 133, 244]); // Google Blue

  // INCOME vs EXPENSE DONUT CHART
  const chartY = 85;
  try {
    const canvas = document.createElement('canvas');
    canvas.width = 400;
    canvas.height = 400;
    const ctx = canvas.getContext('2d');
    if (ctx) {
      const total = income + expense;
      if (total > 0) {
        // Background circle
        ctx.beginPath();
        ctx.arc(200, 200, 180, 0, Math.PI * 2);
        ctx.fillStyle = '#f1f3f4';
        ctx.fill();
        
        // Income slice (green)
        const incAngle = (income / total) * 2 * Math.PI;
        ctx.beginPath();
        ctx.moveTo(200, 200);
        ctx.arc(200, 200, 180, -Math.PI / 2, -Math.PI / 2 + incAngle);
        ctx.fillStyle = '#34A853';
        ctx.fill();

        // Expense slice (red)
        ctx.beginPath();
        ctx.moveTo(200, 200);
        ctx.arc(200, 200, 180, -Math.PI / 2 + incAngle, Math.PI * 1.5);
        ctx.fillStyle = '#EA4335';
        ctx.fill();

        // Donut hole
        ctx.beginPath();
        ctx.arc(200, 200, 110, 0, Math.PI * 2);
        ctx.fillStyle = '#ffffff'; 
        ctx.fill();
        
        // Center text
        ctx.fillStyle = '#202124';
        ctx.font = 'bold 28px Helvetica';
        ctx.textAlign = 'center';
        ctx.fillText(`${Math.round((income / total) * 100)}%`, 200, 195);
        ctx.font = '16px Helvetica';
        ctx.fillStyle = '#5f6368';
        ctx.fillText('Income', 200, 220);
        
        const chartDataUrl = canvas.toDataURL('image/png');
        doc.addImage(chartDataUrl, 'PNG', margin, chartY, 40, 40);
        
        // Legend next to the chart
        const legendX = margin + 45;
        doc.setFontSize(9);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(32, 33, 36);
        doc.text('Income vs Expenses', legendX, chartY + 8);
        
        // Income legend
        doc.setFillColor(52, 168, 83);
        doc.rect(legendX, chartY + 13, 4, 4, 'F');
        doc.setFontSize(7);
        doc.setFont('helvetica', 'normal');
        doc.setTextColor(95, 99, 104);
        doc.text(`Income: ${PDF_CURRENCY}${income.toLocaleString()} (${Math.round((income/total)*100)}%)`, legendX + 6, chartY + 16.5);
        
        // Expense legend
        doc.setFillColor(234, 67, 53);
        doc.rect(legendX, chartY + 21, 4, 4, 'F');
        doc.text(`Expense: ${PDF_CURRENCY}${expense.toLocaleString()} (${Math.round((expense/total)*100)}%)`, legendX + 6, chartY + 24.5);
        
        // Net savings
        doc.setFillColor(66, 133, 244);
        doc.rect(legendX, chartY + 29, 4, 4, 'F');
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(66, 133, 244);
        doc.text(`Net Savings: ${PDF_CURRENCY}${net.toLocaleString()}`, legendX + 6, chartY + 32.5);
      }
    }
  } catch(e) { console.error('Failed to create chart', e); }

  // 3. TABLE DATA
  const tableData = transactions.map(t => [
    t.date,
    t.description,
    categories.find(c => c.id === t.categoryId)?.name || '-',
    accounts.find(a => a.id === t.fromAccountId)?.name || '-',
    `${t.type === 'income' ? '+' : '-'}${t.amount.toLocaleString()}`
  ]);

  autoTable(doc, {
    startY: 130, // Pushed down to make room for pie chart
    head: [['DATE', 'NARRATIVE', 'CATEGORY', 'ASSET', 'VALUE']],
    body: tableData,
    theme: 'striped',
    headStyles: { fillColor: [66, 133, 244], textColor: [255, 255, 255], fontSize: 8, fontStyle: 'bold' },
    bodyStyles: { fontSize: 7, textColor: [60, 64, 67] },
    columnStyles: { 4: { halign: 'right', fontStyle: 'bold' } },
    didParseCell: (data) => {
      if (data.section === 'body' && data.column.index === 4) {
        const rowVal = String(data.cell.raw);
        data.cell.styles.textColor = rowVal.includes('+') ? [16, 185, 129] : [220, 38, 38];
      }
    }
  });

  // Fixed: doc.internal.getNumberOfPages() is not available in the current jsPDF types.
  // Using the public getNumberOfPages() method on the doc instance instead.
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(6);
    doc.setTextColor(161, 161, 170);
    doc.text(`ZENITH AUDIT LEDGER • PAGE ${i} OF ${pageCount} • STRICTLY CONFIDENTIAL`, pageWidth / 2, doc.internal.pageSize.getHeight() - 10, { align: 'center' });
  }

  doc.save(`${fileName}.pdf`);
};

const generateJSON = (transactions: Transaction[], accounts: Account[], categories: Category[]) => {
  const data = JSON.stringify({ transactions, accounts, categories }, null, 2);
  downloadFile(data, `Zenith_Vault_${Date.now()}.json`, 'application/json');
};

const downloadFile = (content: string, name: string, type: string) => {
  const blob = new Blob([content], { type });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = name; a.click();
  URL.revokeObjectURL(url);
};
